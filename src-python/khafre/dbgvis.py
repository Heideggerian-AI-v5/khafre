import cv2 as cv
from khafre.bricks import ReifiedProcess, RatedSimpleQueue, NameTaken
from multiprocessing import Lock, shared_memory
import numpy

class DbgVisualizerInputChannel:
    """
Wrapper around RatedSimpleQueue to ensure correct format of
DbgVisualizer input channel entries.

An input channel entry is a tuple that consists of:
    shmName: str, a shared memory name; this is autogenerated
            when creating a shared memory
    rows, cols: int, dimensions of image in pixels
    channels: int, number of color channels per pixel
    dtype: numpy.dtype, type of the image array elements

Note, currently the only supported image format is 3-channel,
BGR order, with numpy.float32 as dtype.
    """
    def __init__(self):
        self._rsq = RatedSimpleQueue()
    def empty(self):
        return self._rsq.empty()
    def getWithRates(self,block=True,timeout=None):
        return self._rsq.getWithRates(block=block,timeout=timeout)
    def put(self,shmName:str,rows:int,cols:int,channels:int,dtype:numpy.dtype):
        self._rsq.put((shmName,rows,cols,channels,dtype))
    def flush(self):
        self._rsq.flush()

class DbgVisualizer(ReifiedProcess):
    """
Implements a process that will display images in OpenCV
windows. These images are passed to the process as numpy
arrays in shared memories. Information that a new image
is to be displayed, and its format, is given in queues
("input channels").

Note that this process also writes to the shared memory
(to display frame rate and dropped frames info). Thus,
users of the process should only use buffers associated
to DbgVisualizer input channels for debugging-related 
images, not images used in other perception subprocesses.
    """
    def __init__(self):
        super().__init__()
        self._inputs = {}
        self._existing_shm=None
        self._lock=None
    def requestInputChannel(self, name):
        """
Creates a Lock and RatedSimpleQueue and associates them to name,
which will also be used as the title of the OpenCV window.
No other input channel must use the same name, and if name
is already used then the function fails.

A user of this input channel must employ Lock to synchronize
a shared memory.
        """
        if name in self._inputs:
            raise NameTaken
        self._inputs[name] = (Lock(), DbgVisualizerInputChannel())
        return self._inputs[name]
    def doWork(self):
        """
Loop through the registered input channels. If something
is in a channel, display it (together with frame rate and
dropped frame info).
        """
        while True:
            for k,v in self._inputs.items():
                lock, rsq = v
                if not rsq.empty():
                    e,rate,dropped = rsq.getWithRates()
                    shmName,rows,cols,channels,dtype = e
                    self._lock=lock
                    with self._lock:
                        self._existing_shm = shared_memory.SharedMemory(name=shmName)
                        segImg = numpy.ndarray((rows, cols, channels), dtype=dtype, buffer=self._existing_shm.buf)
                        rateAdj = rate
                        if rate is None:
                            rateAdj=0.0
                        rateStr = "%.02f fps | %d%% dropped" % (rateAdj, dropped)
                        textColor = (1.0,1.0,0.0)
                        (text_width, text_height), baseline = cv.getTextSize(rateStr, cv.FONT_HERSHEY_SIMPLEX, 0.5, cv.LINE_AA)
                        cv.rectangle(segImg,(0,0),(text_width, text_height+baseline),(0.0,0.0,0.0),-1)
                        cv.putText(segImg,rateStr,(0, text_height), cv.FONT_HERSHEY_SIMPLEX, 0.5, textColor, 1, cv.LINE_AA)
                        cv.imshow(k, segImg)
                        self._existing_shm.close()
            cv.waitKey(10)
    def cleanup(self):
        """
Loop through registered input channels and flush them.
Also close opened visualization windows.
        """
        def _x(name):
            try:
                cv.destroyWindow(k)
            except:
                pass
        _ = [(_x(k), v[1].flush()) for k,v in self._inputs.items()]
        if self._existing_shm is not None:
            # Apparently it is safe to close a shared memory twice -- second call is just ignored.
            self._existing_shm.close()
        # Python promises to release a lock when a with block is exited FOR ANY REASON,
        # but just in case, try to release the lock here.
        if self._lock is not None:
            try:
                self._lock.release()
            except:
                pass

